Everything is in README.md

**Account Abstraction in Ethereum**
![img1](images/account-abstraction-ethereum.png)  

**Account Abstraction in ZkSync**
![img1](images/account-abstraction-zksync.png)  

# Account Abstraction
Account Abstraction (AA) fundamentally redefines user accounts in Web3. Instead of traditional Externally Owned Accounts (EOAs) controlled solely by a private key, AA allows user accounts to be smart contracts. This paradigm shift enables programmable validity conditions – dictating who can send transactions and under what circumstances – and custom execution logic, offering unprecedented flexibility and security. These smart contract-based accounts are often referred to as "smart contract wallets."

## The Bottleneck: Why Traditional Crypto Wallets Hinder Adoption

The traditional approach to managing crypto assets has long been a significant barrier to widespread adoption. Consider the typical user journey:

1. A user receives a 12-word seed phrase.

2. This seed phrase generates a private key.

3. This private key is the sole authenticator for signing all transactions.

This model, while secure in theory, presents several critical pain points for the average user:

* **Complexity**: Managing seed phrases and private keys is a daunting task. Users are expected to become security experts overnight, safeguarding these cryptic strings of characters.

* **High Stakes**: The loss of a seed phrase or private key typically means irreversible loss of access to all associated funds. There are no "forgot password" options.

* **Security Risks**: If a private key or seed phrase is accidentally leaked or compromised, malicious actors can gain unfettered access to and drain the user's wallet.

* **Gas Fee Friction**: Every on-chain action, no matter how small, requires the user to hold and spend the blockchain's native token (e.g., ETH on Ethereum) for gas fees. This "gas problem" is a constant hurdle, especially for new users who might not have any native tokens to begin with.

* **Limited Wallet Privacy**: All transactions originating from a single private key are linked, potentially revealing a user's activity patterns.

* **Batching Inefficiencies**: Performing multiple operations often requires deploying an intermediary smart contract, adding complexity and cost.

These issues collectively create a poor user experience, making it difficult to onboard new users to the world of decentralized finance and Web3.

## What is Account Abstraction? The Core Shift in Transaction Validation

Account Abstraction fundamentally redefines how transactions are authorized and validated on a blockchain. The core idea is to move away from a rigid system where transaction validity is solely tied to an Elliptic Curve Digital Signature Algorithm (ECDSA) signature generated by a private key. Instead, AA allows for **arbitrary validation logic** defined within a smart contract.

To put it simply:

* **Traditional Model**: Private Key = Wallet. The private key is the ultimate authority.

* **Account Abstraction Model**: Programmable Logic = Wallet. The authority and validation rules are defined by the code within a smart contract account.

This shift means that instead of the blockchain protocol itself dictating that only a private key signature can authorize a transaction from an Externally Owned Account (EOA), the account itself (now a smart contract) dictates the conditions under which a transaction is considered valid.

This programmable validity opens up a wealth of possibilities:

* **Social Login/Recovery**: Users could authorize transactions using familiar credentials like a Google account, GitHub, or even biometrics, abstracting away the need to directly manage private keys.

* **Multi-signature (Multi-sig) Wallets**: Require approvals from multiple parties (e.g., three out of five authorized signers) before a transaction is executed.

* **Spending Limits**: Enforce daily, weekly, or per-transaction spending caps directly at the account level.

* **Time Locks**: Permit transactions only during specific windows (e.g., business hours) or after a certain delay.

* **Parental Controls**: A wallet for a minor could be configured such that transactions initiated by the child require approval from a parent's account before execution.

## Gas Abstraction: Solving the "Need Gas" Problem with Paymasters
A significant corollary of programmable validation is **gas abstraction**. Because the account's validation logic is flexible, AA enables mechanisms where someone other than the user can pay for their transaction gas fees.

This directly addresses the friction point where users need native tokens for every interaction. With AA, a dApp developer, a project, or a dedicated third-party service (known as a "Paymaster") can sponsor transactions. The user can interact with a dApp without needing to first acquire and hold ETH (or the L2's native token) specifically for gas.

## How Account Abstraction Works: EIP-4337 vs. Native Implementations
The implementation of Account Abstraction varies, leading to different levels of complexity. There are two primary approaches:

1. **Ethereum (EIP-4337)**: This standard implements Account Abstraction on top of the existing Ethereum protocol without requiring core consensus changes. It relies on a higher-level infrastructure, including a special smart contract (`EntryPoint.sol`) and an alternative mempool for user operations. EIP-4337 went live on Ethereum mainnet on March 1st, 2023.

2. **Native Account Abstraction (e.g., zkSync)**: Some Layer 2 solutions and newer blockchains build Account Abstraction directly into their core protocol. This often leads to a more streamlined and integrated experience.

### Traditional Ethereum Transaction Flow (Recap)
Before diving into EIP-4337, let's quickly recap the traditional Ethereum transaction flow:

1. **Off-Chain**: A user, using a wallet like MetaMask, signs transaction data with their private key. This signature, along with the transaction details and gas payment, is prepared.

2. **On-Chain**: The signed transaction is broadcast to an Ethereum node.

3. The node validates the transaction (including the signature and sufficient gas) and, if valid, adds it to its local mempool.

4. Miners/validators pick transactions from the mempool to include in a new block, which is then added to the blockchain.

## Account Abstraction on Ethereum via EIP-4337: A Detailed Look
EIP-4337 introduces a new, parallel system for transaction processing that leverages smart contracts to achieve account abstraction. The flow involves several key components:

1. **Deploy a Smart Contract Wallet (SCW)**:
Instead of relying solely on an EOA, the user interacts through a **Smart Contract Wallet (SCW)**. This SCW is a smart contract deployed on the blockchain (e.g., `MyNewAccount.sol`) that contains the custom validation logic. This logic dictates what constitutes a valid authorization for that specific account – it could be a signature from a specific key (mimicking an EOA), a multi-sig condition, or a check against an off-chain authentication service.

2. **Construct and Send a "UserOperation" (UserOp) to the Alt Mempool**:
When a user wants to perform an action (e.g., send tokens, interact with a DeFi protocol), their wallet interface (now AA-aware) constructs a **UserOperation** (`UserOp`) object. This is not a standard Ethereum transaction. The `UserOp` struct, defined in the EIP-4337 specification, includes fields such as:

* `sender`: The address of the user's SCW.

* `nonce`: A sequence number to prevent replay attacks.

* `callData`: The actual operation to be executed by the SCW (e.g., the function call and parameters for an ERC20 transfer).

* Gas-related fields (`callGasLimit`, `verificationGasLimit`, `preVerificationGas`, `maxFeePerGas`, `maxPriorityFeePerGas`).

* `paymasterAndData`: Optional data for specifying a Paymaster to sponsor gas fees.

* `signature`: The signature that satisfies the SCW's custom validation logic.

This `UserOp`, signed according to the SCW's rules, is then sent to a separate, off-chain peer-to-peer network known as the **Alternative Mempool (Alt Mempool)**. This mempool is specifically for `UserOps` and operates independently of Ethereum's main transaction mempool.

3. **Bundlers Process UserOps**:
Specialized nodes participating in the Alt Mempool network are called **Bundlers**. Their role is to:

* Listen for `UserOps` in the Alt Mempool.

* Validate each `UserOp` by simulating its validation logic against the target SCW.

* Bundle multiple valid `UserOps` together into a single, standard Ethereum transaction.

* Crucially, the **Bundler pays the gas fee** for this bundled Ethereum transaction sent to the main Ethereum network. They are later compensated either by the SCWs themselves or by Paymasters.

4. **Bundler Calls the `EntryPoint.sol` Contract**:
The Bundler submits this bundled transaction by calling a specific function (typically `handleOps`) on a single, globally deployed smart contract called `EntryPoint.sol`. This contract (developed and maintained by the `eth-infinitism` group, with support from the Ethereum Foundation) acts as the central orchestrator for EIP-4337. Its canonical address (e.g., `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789` for v0.6/v0.7) is known and trusted.

The `EntryPoint.sol` contract then performs its own set of critical operations:

* It iterates through each `UserOp` in the bundle.

* For each `UserOp`, it first verifies the `UserOp`'s signature and other parameters by calling a validation function on the user's SCW (e.g., `validateUserOp`).

* It checks if the SCW has enough funds to pay the Bundler for gas, or if a specified Paymaster has agreed to cover the costs.

5. **Smart Contract Wallet Executes the Transaction**:
If the validation step in `EntryPoint.sol` (which involves calling the SCW's validation logic) is successful, `EntryPoint.sol` then calls another function on the user's SCW to execute the actual intended operation. This is where the `callData` from the `UserOp` is executed (e.g., making a swap on Uniswap, or lending assets on Aave).

* Importantly, during this execution phase, the `msg.sender` for the target dApp interaction will be the address of the user's SCW, not the Bundler or the `EntryPoint` contract. This ensures that from the perspective of other smart contracts, the SCW is the true originator of the action.
The results of these operations are then recorded on the Ethereum blockchain.

6. **Optional EIP-4337 Add-ons**:

* **Signature Aggregators**: EIP-4337 supports the use of Signature Aggregator contracts. These contracts can be used by `EntryPoint.sol` to validate aggregated signatures (e.g., BLS signatures). This is particularly useful for multi-sig SCWs or for batching operations, as it can significantly reduce gas costs by verifying multiple signatures in a single operation.

* **Paymasters**: As mentioned, a Paymaster is a smart contract that can agree to pay the gas fees for a `UserOp`. The `UserOp` can specify a Paymaster contract and include data that the Paymaster requires for its validation (e.g., a signature from the dApp sponsoring the transaction). If a Paymaster is used and successfully validates, it reimburses the Bundler via the `EntryPoint.sol` contract. If no Paymaster is used, the user's SCW must have sufficient native token balance, which `EntryPoint.sol` will transfer to the Bundler as compensation.

The EIP-4337 flow, while powerful, involves several interconnected components: the user's SCW, the UserOp object, the Alt Mempool, Bundlers, and the central `EntryPoint.sol` contract.

## Native Account Abstraction: The zkSync Example
Blockchains with native Account Abstraction, such as zkSync Era, integrate AA principles directly into their core protocol, often resulting in a simpler architecture for developers and users.

In zkSync Era:

* The roles of the Alt Mempool and Bundlers are effectively handled by the regular chain nodes/sequencers.

* **Every account is fundamentally a smart contract**. Even when a user creates an account using a familiar tool like MetaMask (which traditionally generates an EOA), zkSync automatically deploys a default smart contract account implementation for that address.

* This default account contract (e.g., `DefaultAccount.sol` in the `matter-labs/era-contracts` repository) implements standard interfaces like `IAccount` and includes functions such as `validateTransaction`, `executeTransaction`, and `isValidSignature`. By default, this contract mimics traditional EOA behavior, validating transactions based on an ECDSA signature from the associated private key.

* However, users or developers can **override** this default implementation by deploying custom smart contract code to their account address. This custom code can then define any arbitrary validation logic, effectively turning any account into a fully programmable smart contract wallet.

The simplified flow on a native AA chain like zkSync might look like this:

1. **Off-Chain**: A signer (which could be a traditional private key, a social login mechanism, or a multi-sig scheme) signs the transaction data according to the account's logic.

2. **On-Chain**: The signed transaction is sent to zkSync nodes. These nodes natively understand AA and can directly call the validation logic within the user's account contract.

3. If valid, the transaction is executed by the user's account contract, and the results are included in a block on the zkSync blockchain.

This native approach bypasses the need for a separate Alt Mempool and the `EntryPoint.sol` contract, as the core protocol itself is designed to handle programmable account validity.

## The Future is Abstracted: Enhanced Usability for Web3
Account Abstraction, whether through EIP-4337 on Ethereum or via native implementations on Layer 2s and other blockchains, represents a monumental step towards improving blockchain usability. While the EIP-4337 mechanism on Ethereum involves a complex interplay of off-chain and on-chain components, its goal is to make interacting with Web3 applications as seamless and intuitive as using Web2 applications.

By abstracting away the complexities of private key management and gas payments, AA paves the way for features like social recovery, sponsored transactions, spending limits, and much more. Ultimately, this will lower the barrier to entry, making decentralized technologies more accessible to a broader audience and helping to onboard the next wave of users into the crypto ecosystem.

---

## Ethereum's Approach to Account Abstraction: ERC-4337
The Ethereum ecosystem primarily tackles Account Abstraction through the ERC-4337 standard. This standard introduces a decentralized infrastructure layer without requiring consensus-level protocol changes.

**Key Components of ERC-4337**:

* `EntryPoint.sol`: This is a globally recognized, trusted smart contract. It acts as the central coordinator for AA transactions. Bundlers submit `UserOperations` to this contract, which then orchestrates their validation and execution against the target smart contract wallet.

* `UserOperation`: Instead of standard Ethereum transactions, users (or dApps on their behalf) create `UserOperation` objects. These objects detail the intended action, signature, gas parameters, and other necessary data for the smart contract wallet.

* `Alt-Mempool`: `UserOperations` are not broadcast to the standard Ethereum transaction mempool. Instead, they are sent to a separate, alternative mempool (often called an "alt-mempool").

* **Bundlers**: These are specialized actors who monitor the alt-mempool. They select `UserOperations`, bundle them into a single standard Ethereum transaction, and submit this bundle to the `EntryPoint.sol` contract. Bundlers pay the gas for this Layer 1 transaction and are subsequently reimbursed, typically from the smart contract wallet or a Paymaster.

**Minimal Ethereum AA Implementation: `MinimalAccount.sol`**

The `MinimalAccount.sol` contract, found within the `src/ethereum/` directory, serves as a foundational example of an ERC-4337 compatible smart contract wallet. Its primary design goal is simplicity, offering a clear starting point for developers.

   * **Core Functionality**:

       * It permits transaction initiation by either its "owner" (the EOA that deployed it) or the `EntryPoint.sol` contract.

       * The `validateUserOp` function is crucial for verifying an incoming `UserOperation` from the `EntryPoint`. It typically checks signatures and other conditions.

       * The `execute` function is called by the `EntryPoint` after successful validation to perform the actual transaction logic (e.g., calling another contract).

   * **Extensibility**: While minimal, `MinimalAccount.sol` is designed for extension. Developers can incorporate:

       * **Paymaster Logic**: To allow third parties (Paymasters) to sponsor transaction fees.

       * **Custom Signature Schemes**: Integrating alternative signature validation, potentially via a Signature Aggregator.

       * **Spending Allowances/Limits**: Enforcing rules on transaction values or frequencies.

       * **Session Keys**: Implementing temporary, permission-restricted keys (e.g., using Google session keys) for specific interactions.

**Ethereum AA Transaction Flow (ERC-4337)**:

1. **UserOperation Creation**: A user, often interacting through a dApp, signs data that forms a `UserOperation`.

2. **Submission to Alt-Mempool**: The `UserOperation` is sent to an alt-mempool.

3. **Bundler Action**: Bundlers retrieve `UserOperations` from the alt-mempool, package them into a standard Ethereum transaction, and submit this bundle to the `EntryPoint.sol` contract on-chain.

4. **Validation**: The `EntryPoint.sol` contract calls the `validateUserOp` function on the target smart contract wallet (e.g., an instance of `MinimalAccount.sol`). This function verifies the operation's legitimacy (e.g., signature, nonce).

5. **Execution**: If `validateUserOp` succeeds, the `EntryPoint.sol` contract then calls the `execute` function on the smart contract wallet, which carries out the intended action (e.g., an ERC20 token transfer or a smart contract interaction).

6. **Optional Paymaster Involvement**: A Paymaster contract can be specified in the `UserOperation` to cover the gas fees, enabling gasless experiences for the end-user.

## zkSync's Native Account Abstraction: A Built-in Solution
zkSync approaches Account Abstraction differently by integrating it directly into its Layer 2 protocol. This native implementation offers a more streamlined experience and distinct characteristics compared to Ethereum's ERC-4337.

**Key Differences and Features in zkSync Native AA**:

* **No Alt-Mempool**: AA transactions on zkSync are submitted to the regular zkSync mempool, just like EOA transactions. There's no need for a separate mempool infrastructure.

* **Type 113 Transactions**: AA transactions are designated as `Type 113` (hexadecimal `0x71`). This specific type signals to the zkSync protocol that the transaction originates from a smart contract account and requires special handling.

* **Bootloader**: A critical system-level component in zkSync, the Bootloader plays a central role in processing AA transactions. During both the validation and execution phases of an AA transaction, the `msg.sender` to the smart contract wallet will be the Bootloader's address.

* **Smart Contract as `from` Address**: A significant distinction is that in zkSync, the `from` field of a `Type 113` transaction can be the address of the smart contract wallet itself. This contrasts with Ethereum, where the `from` field is always an EOA.

**Minimal zkSync AA Implementation: `ZkMinimalAccount.sol`**

The `ZkMinimalAccount.sol` contract, located in `src/zksync/` of the repository, demonstrates a basic smart contract wallet utilizing zkSync's native AA.

* **Important Contract Functions**:

   * `validateTransaction(bytes32 _txHash, bytes32 _suggestedSignedHash, Transaction _transaction)`: This function is paramount. It's called by the Bootloader to validate the incoming transaction. Responsibilities include verifying signatures against `_suggestedSignedHash` (which is `keccak256(abi.encodePacked(txHash, EIP1271_SUCCESS_RETURN_VALUE))`) and, crucially, incrementing the account's nonce to prevent replay attacks.

   * `executeTransaction(bytes32 _txHash, bytes32 _suggestedSignedHash, Transaction _transaction)`: After successful validation, the Bootloader calls this function to execute the actual logic defined in the `_transaction` payload.

   * `payForTransaction(...)`: This function (or logic within `validateTransaction`) handles the payment of transaction fees, ensuring the account can cover the costs or that a Paymaster will.

**zkSync Native AA Transaction Flow**:

The lifecycle of a `Type 113` transaction on zkSync involves two main phases, orchestrated by the zkSync system and the Bootloader:

* **Phase 1: Validation**

   1. **Submission**: The user (or dApp) sends the `Type 113` transaction to a zkSync API client. The `from` field of this transaction is the address of the `ZkMinimalAccount.sol` instance.

   2. `msg.sender` **is Bootloader**: For both validation and execution phases, the `msg.sender` to the `ZkMinimalAccount.sol` will be the Bootloader.

   3. **Nonce Check (System)**: The API client, interacting with the NonceHolder system contract, verifies the uniqueness of the transaction's nonce for the account.

   4. **Account Validation Call**: The API client (via the Bootloader) calls `validateTransaction` on the `ZkMinimalAccount.sol`. This function must perform signature checks and update the account's nonce.

   5. **Nonce Update Verification (System)**: The API client checks if the `ZkMinimalAccount.sol` correctly updated its nonce.

   6. **Fee Payment Check (System)**: The API client calls `payForTransaction` on the account (or invokes Paymaster logic if specified) to ensure the transaction fees can be covered.

   7. **Bootloader Payment Verification (System)**: The API client confirms that the Bootloader will be compensated for processing the transaction.

* **Phase 2: Execution**

   1. **To Sequencer**: The validated transaction is passed from the API client to the main zkSync node/sequencer.

   2. **Account Execution Call**: The main node (via the Bootloader) calls `executeTransaction` on the `ZkMinimalAccount.sol`, which then performs the intended operations.

   3. **Post-Transaction (Optional)**: If a Paymaster was involved, its `postTransaction` method might be called.

## Comparing Implementations: Ethereum (ERC-4337) vs. zkSync Native AA
Understanding the practical differences is key when observing on-chain activity.

* **zkSync Sepolia Example (Native AA)**:

   * Consider a transaction approving USDC spending from a deployed `ZkMinimalAccount` (e.g., `0xCB38...5691`).

   * On the zkSync Sepolia explorer, the `from` address of this transaction (hash `0x4322...d0fd`) will be the `ZkMinimalAccount` smart contract address itself. This directly demonstrates the smart contract initiating the call.

* **Ethereum (Arbitrum Example with ERC-4337)**:

   * Consider a similar USDC approval from a `MinimalAccount` deployed on Arbitrum (an Ethereum L2 that can support ERC-4337).

   * On Arbiscan, the transaction (hash `0x03f9...154b`) will show its `from` **address** as a **Bundler** (e.g., `0x9EA9...F6fC`).

   * The transaction's `to` **address** will be the `EntryPoint.sol` contract (e.g., version 0.7.0 at `0x000...032`).

   * However, by inspecting the transaction logs, one would find an `Approval` event emitted by the USDC contract where the `owner` (the account granting approval) is the MinimalAccount smart contract wallet address (e.g., `0x83Ad...AAf`). This confirms that, despite the Bundler being the transaction submitter, the smart contract wallet was the effective initiator of the state change via the EntryPoint.


## Core Components: Paymasters and Signature Aggregators
Both ERC-4337 and zkSync's native AA can be enhanced with optional components:

  * **Paymasters**: These are smart contracts that can sponsor transaction fees on behalf of users. This enables "gasless" transactions for the end-user, where the dApp, a protocol, or another entity covers the costs. Paymasters are integrated into the validation flow, agreeing to pay if certain conditions are met.

  * **Signature Aggregators**: In scenarios involving multiple `UserOperations` (especially in ERC-4337) or complex multi-signature schemes within a single account, Signature Aggregators can validate multiple signatures in a batch. This can lead to significant gas savings by reducing the on-chain verification overhead.

## Code Overview and Extensibility

* `src/ethereum/MinimalAccount.sol`: For ERC-4337 compatible chains.

* `src/zksync/ZkMinimalAccount.sol`: For zkSync and its native AA.

These minimal contracts are designed as starting points. The true power of Account Abstraction is unlocked by extending their validation logic (`validateUserOp` on Ethereum, `validateTransaction` on zkSync). Developers can build upon these bases to incorporate:

* **Advanced Paymaster integrations**.

* **Novel signature schemes** (e.g., BLS signatures, quantum-resistant signatures).

* **Granular spending allowances** or time-based spending limits.

* **Session keys** for enhanced dApp interactions, allowing temporary, restricted access without exposing primary owner keys. For example, a game might be granted a session key that can only sign transactions related to in-game actions for a limited duration.

## Unlocking Advanced Use Cases with Account Abstraction
The customizability offered by these minimal AA frameworks paves the way for sophisticated wallet features:

* **Session Keys**: Granting temporary, limited permissions to dApps or other services for specific actions (e.g., a gaming session key that can only sign game-related transactions for a set period).

* **Custom Multisig**: Implementing complex N-of-M signature schemes beyond standard multisigs, potentially involving role-based access or conditional approvals (e.g., requiring 2 out of 3 specific signers plus a time-locked passcode).

* **Social Recovery**: Enabling users to regain access to their accounts through a set of trusted guardians or social connections, rather than relying solely on a seed phrase.

* **Gas Sponsorship**: Facilitating frictionless onboarding and interaction by allowing dApps or protocols to cover transaction fees for their users via Paymasters.

### Key Takeaways for Developers
Building and experimenting with both the Ethereum ERC-4337 style and zkSync's native Account Abstraction implementations provides invaluable insight into their respective nuances, strengths, and trade-offs. The core innovation lies in the programmable validation logic within the smart contract wallet itself (`validateUserOp` or `validateTransaction`). This programmability is what empowers developers to create highly secure, user-friendly, and feature-rich Web3 experiences, moving beyond the limitations of traditional EOA wallets. By understanding these foundational patterns, developers can choose the most suitable AA approach for their target blockchain and application needs.

## Understanding the ERC-4337 Interaction Flow
To correctly implement `MinimalAccount.sol`, we must understand the ERC-4337 standard. This Ethereum Improvement Proposal (EIP) outlines the architecture for account abstraction without requiring consensus-layer changes. You can find the full specification at eips.ethereum.org/EIPS/eip-4337.

The ERC-4337 flow can be visualized as follows:

1. **Off-Chain User Action**: A user signs data, which forms a `UserOperation`. This `UserOperation` is essentially a pseudo-transaction that describes the action the user wants their smart contract wallet to perform.

2. **Alternative Mempool (Bundlers)**: The signed `UserOperation` is sent to specialized nodes called Bundlers. Bundlers are actors in the ERC-4337 ecosystem that listen for `UserOperations` on an alternative, off-chain mempool. They validate these operations (checking for correctness, potential profitability, etc.).

3. **On-Chain Execution via EntryPoint**: Bundlers package valid `UserOperations` into a standard Ethereum transaction and send it to a globally deployed singleton contract called the `EntryPoint.sol`.

4. **EntryPoint Contract Logic**: The `EntryPoint` contract is the central orchestrator. It first verifies the `UserOperation`. This verification step involves calling a specific function on the user's smart contract wallet (`MinimalAccount.sol`). If verification succeeds, the `EntryPoint` then executes the UserOperation, again by calling a function on the user's smart contract wallet. The `EntryPoint` also handles interactions with Paymasters (contracts that can sponsor gas fees) and Signature Aggregators (for more efficient signature schemes).

5. **Smart Contract Wallet (Account)**: `MinimalAccount.sol` is the user's smart contract wallet. The `EntryPoint` interacts directly with this contract for both validating the `UserOperation` (e.g., checking the signature) and executing the intended action (e.g., calling another contract).

6. **Blockchain Inclusion**: The entire interaction, initiated by the Bundler's transaction to the `EntryPoint`, is ultimately included in a block on the Ethereum blockchain.

The `UserOperation` struct, defined by ERC-4337, is crucial. It bundles all necessary data for an off-chain pseudo-transaction, including fields like `sender` (the smart contract wallet's address), `nonce`, `callData` (the action to execute), various gas limits, `paymasterAndData`, and the `signature`. This is the data structure passed around in the alt-mempool.

When the `EntryPoint` contract interacts with an account contract on-chain, it uses a packed version of this `UserOperation`.

---

## Advance Debugging in Foundry

Foundry has integrated debugger. If you have a specific test function failing, such as testEntryPointCanExecuteCommands, you can invoke the debugger with increased verbosity using the following command:

```bash
forge test --debug testEntryPointCanExecuteCommands -vvv
```
*(Initially, you might run forge test --mt testEntryPointCanExecuteCommands -vvv to match the test name, and then add the --debug flag to dive deeper.)*

Executing this command launches a low-level debugger interface. This interface provides a wealth of information, including EVM opcodes, the current call stack, memory contents, and, importantly, the corresponding Solidity source code context when available.

### Tip 1: Instantly Navigate to the Revert Location
When a transaction reverts, your first goal is to find out where it reverted. Foundry's debugger offers a handy shortcut for this:

* **Keyboard Shortcut**: `Shift + G`

Pressing `Shift + G` instructs the debugger to jump directly to the EVM instruction that caused the revert. If source mapping is available, it will also highlight the corresponding line in your Solidity code.

### Tip 2: Understanding the Pre-Revert State by Stepping Backwards
Knowing where the revert happened is useful, but to understand *why*, we often need to inspect the state and execution path leading up to it. The debugger allows us to step backward through the execution trace.

* **Keyboard Shortcut**: `J` (repeatedly press to step to the previous EVM opcode)

   * The on-screen help often shows `[k/j]: prev/next op`, where `k` steps forward (next opcode) and `j` steps backward (previous opcode).

Sometimes you might encounter messages like "No source map for contract ......." This means the debugger doesn't have the source code mapping for that specific part of the dependency. However, by continuing to step back, you will eventually land on a relevant Solidity line within the contract itself, if its source is available in your project or in your project dependency(in `lib/`).

---

## Transitioning to zkSync Account Abstraction
While EIP-4337 provides a robust framework for Account Abstraction on Ethereum, its reliance on an alt-mempool, external Bundlers, and the EntryPoint contract introduces a degree of complexity to the overall architecture.

**zkSync's Native Approach**

zkSync, as a Layer 2 scaling solution, has taken a different path by building Account Abstraction **natively into its protocol level**. This fundamentally changes and simplifies how AA is handled.

* **Key Distinction**: On zkSync, there is no requirement for a separate alt-mempool or external Bundler entities in the same way EIP-4337 mandates them for Ethereum. The zkSync sequencer and its underlying protocol are inherently designed to manage AA transactions.

* **Transaction Type 113**: To interact with a Smart Account on zkSync, users (or their wallets) send a special transaction of `Type 113`. This type signals to the zkSync network that the transaction originates from or targets a Smart Account and requires AA logic to be processed.

* **Combined Mempool**: zkSync effectively features a "combined mempool." The distinction between a standard mempool and an AA-specific alt-mempool dissolves. The native protocol understands how to route and process Type 113 transactions alongside regular transactions.

**The zkSync AA Flow**

1. A user (e.g., via a wallet like MetaMask configured for zkSync) initiates and sends a Type 113 transaction directly to the zkSync network.

2. This transaction specifies the `from` address as the Smart Account address.

3. The zkSync protocol itself, upon receiving this Type 113 transaction, directly handles calling the appropriate validation logic defined within the target Smart Account.

4. If the Smart Account's validation logic confirms the transaction's validity, the transaction is then executed.

5. Paymaster functionality is also natively supported within zkSync's AA model, allowing for sponsored transactions.

This native integration aims to provide a more streamlined and potentially more efficient AA experience compared to the layered approach of EIP-4337 on Ethereum L1.

**Important Resources**

* **EIP-4337**: The official Ethereum Improvement Proposal for Account Abstraction using an alternative mempool.

* **zkSync Documentation**: Particularly the sections on the "Bootloader," which is responsible for processing transactions (including Type 113 AA transactions) in batches. (Refer to `docs.zksync.io/zk-stack/components/zksync-evm/bootloader`).

---

## Deploying an ERC-4337 Smart Account and Sending a UserOperation on Arbitrum mainnet

1. **Deploying the MinimalAccount to Arbitrum Mainnet**

```bash
forge script script/DeployMinimal.s.sol --rpc-url $ARBITRUM_RPC_URL --account smallmoney --broadcast --verify
```
2. **Preparing and Sending a UserOperation via `MinimalAccount`**
With our `MinimalAccount` deployed, the next step is to send a `UserOperation` through it. This UserOp will instruct our smart account to interact with another contract on Arbitrum. We'll use another Foundry script, `SendPackedUserOp.s.sol`, for this purpose.

The core logic resides within the `run()` function of this script, which we need to populate.    

**Coding the `run()` function in `SendPackedUserOp.s.sol`:**

a. **Initialize** `HelperConfig`: This utility contract helps manage network-specific configurations.

```bash
HelperConfig helperConfig = new HelperConfig();
```

b. **Define Target Contract Address (`dest`)**: This is the address of the contract our UserOp will ultimately call. For this example, we'll target the Arbitrum mainnet USDC contract.

```solidity
address dest = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831; // Arbitrum Mainnet USDC
```

c. **Define Call Value (`value`)**: Since our interaction (an `approve` call) doesn't involve sending ETH, this is `0`.

```solidity
uint256 value = 0;
```

d. **Define** `functionData`: This is the calldata for the internal call our `MinimalAccount` will make. We'll call the `approve` function on the USDC contract.
   * First, import `IERC20` if not already present
   * Then, encode the approve call:
   ```solidity
   bytes memory functionData = abi.encodeWithSelector(
    IERC20.approve.selector,
    0x9EA9b0cc1919def1A3CfAEF4F7A66eE3c36F86fC, // Spender address (another EOA)
    1e18 // Amount to approve (Note: USDC has 6 decimals, so 1e18 is a very large USDC amount)
   );
   ```
   *(The large approval amount is for demonstration; in a real scenario, use appropriate values and consider USDC's decimal precision.)*


e. **Define** `executeCallData`: This is the calldata for the `MinimalAccount`'s `execute` function. This function, when called by the EntryPoint, will perform the internal `approve` call defined above.

   * Import `MinimalAccount` if not already present
   * Encode the `execute` call:
   ```solidity
   bytes memory executeCallData = abi.encodeWithSelector(
    MinimalAccount.execute.selector,
    dest,
    value,
    functionData
   );
   ```

f. **Generate Signed UserOperation (`userOp`)**: We'll use a helper function, `generateSignedUserOperation` (assumed to be defined elsewhere in the script or an imported library), which handles creating the `PackedUserOperation` struct, fetching the nonce, calculating the UserOp hash, and signing it with the appropriate key.

```solidity
// The MinimalAccount address deployed earlier
address minimalAccountAddress = address(0x03Ad95a54f02A40180D45D76789C448024145aaF);
PackedUserOperation memory userOp = generateSignedUserOperation(
    executeCallData,
    helperConfig.getConfig(), // Contains network config like EntryPoint address
    minimalAccountAddress
);
```

g. **Prepare UserOp Array (`ops`)**: The EntryPoint's `handleOps` function expects an array of UserOperations.

```solidity
PackedUserOperation[] memory ops = new PackedUserOperation[](1);
ops[0] = userOp;
```

h. **Broadcast Transaction to EntryPoint**: Using Foundry's cheatcodes, we simulate broadcasting the transaction. The `handleOps` function is called on the ERC-4337 EntryPoint contract

```solidity
vm.startBroadcast();
// The beneficiary address receives gas refunds
address payable beneficiary = payable(helperConfig.getConfig().account); // Typically the burner account
IEntryPoint(helperConfig.getConfig().entryPoint).handleOps(ops, beneficiary);
vm.stopBroadcast();
```

**Important Setup**:
Before running this script, some configuration is necessary:

* `HelperConfig.s.sol` **Update**: This file must be updated with Arbitrum-specific configurations, such as the official EntryPoint contract address and the "account" address (your burner/smallmoney account used for broadcasting and as beneficiary).

* **Wallet/Private Keys**: Ensure your Foundry environment is correctly configured with the private keys, especially for the "smallmoney" account that will sign and broadcast the transaction to the EntryPoint.

**A Note on Testing Account Abstraction**:
Testing ERC-4337 account abstraction can be challenging. Ideally, one would use dedicated testnets fully supporting the ERC-4337 infrastructure (Bundlers, EntryPoint, Paymasters). In the absence of readily available, fully-fledged ERC-4337 testnets at the time of demonstration, deploying and testing directly on a mainnet like Arbitrum (using a burner account and minimal funds) was chosen, despite the inherent costs and risks.

**Executing the UserOperation Script**:
With the script prepared and configurations in place, we can run the command to send the UserOperation.

```bash
forge script script/SendPackedUserOp.s.sol --rpc-url $ARBITRUM_RPC_URL --account smallmoney --broadcast -vvv
```
3. **Verifying the UserOperation on Arbiscan**
After the script execution (or by looking up the pre-executed transaction), we can verify the outcome on Arbiscan. Navigate to the transaction hash generated by the `handleOps` call.

**Transaction Details on Arbiscan:**

* **Status**: Should be "Success".

* **Timestamp**: Will reflect when the transaction was mined.

* **From**: The address of your "smallmoney" burner account (the EOA that submitted the UserOp to the EntryPoint).

* **To (Interacted With)**: The ERC-4337 EntryPoint contract address on Arbitrum.

* **Input Data**: Decoded, this will show the call to the `handleOps` function. You'll see the `ops` array containing your `PackedUserOperation` (including the `sender` as your `MinimalAccount` address, `nonce`, the `callData` which is `executeCallData`, `signature`, etc.) and the `beneficiary` address.

**Internal Transactions and Event Logs**:
The crucial part is to inspect the event logs generated by this transaction:

1.**`Approval` Event (from USDC Token Contract)**: You should see an `Approval` event emitted by the USDC Token contract (`0xaf88...`). This confirms that the internal call within your UserOperation successfully executed the approve function on the USDC contract. The log details will show:

   * `owner`: The address of your `MinimalAccount`.

   * `spender`: The address you specified in `functionData`.

   * `value`: The amount approved (Arbiscan might display this based on 6 decimals for USDC, e.g., `1000000` if `1e6` was the effective amount after decimal conversion, or a larger number if `1e18` was directly interpreted, though USDC uses 6 decimals). The key is that an approval occurred.

2. `UserOperationEvent` (**from EntryPoint Contract**): The EntryPoint contract itself will emit a `UserOperationEvent`. This event signals the successful processing of your UserOp and includes vital information:

   * `userOpHash`: The unique hash of your UserOperation.

   * `sender`: The address of your `MinimalAccount`.

   * `paymaster`: Address of the paymaster if one was used (likely `address(0)` if not).

   * `nonce`: The nonce used for this UserOp from your `MinimalAccount`.

   * `success`: A boolean indicating if the UserOp execution was successful (should be `true`).

   * `actualGasCost`: The actual gas cost paid for the UserOp.

   * `actualGasUsed`: The gas used by the UserOp execution.

Seeing these events, particularly the `Approval` from USDC and a successful `UserOperationEvent`, confirms that your UserOperation was correctly processed by the EntryPoint. The EntryPoint, in turn, called the `execute` function on your `MinimalAccount`, which then successfully performed the intended internal transaction (the USDC approval).

---

## Account Abstraction: ZK Sync's Native Edge vs. Ethereum's EIP-4337
Account Abstraction (AA) fundamentally changes how accounts operate on a blockchain, allowing smart contracts to act as first-class accounts. However, ZK Sync and Ethereum (with EIP-4337) approach AA differently.

In **ZK Sync**, account abstraction is a **native, first-class feature**. This means the underlying protocol is designed to understand and handle abstracted accounts directly. There's no need for a separate layer of smart contracts to simulate AA functionality. Consequently, ZK Sync doesn't distinguish between "user operations" (a term from EIP-4337) and regular transactions at a fundamental level. To the ZK Sync system, all are simply "transactions."

In contrast, **Ethereum's EIP-4337** implements account abstraction through an overlay system. It relies on a series of smart contracts, such as an `EntryPoint` contract and smart contract wallets, built on top of the existing Externally Owned Account (EOA) model. While powerful, this is an application-layer solution rather than a protocol-native one.

This native integration in ZK Sync simplifies the architecture and offers a more streamlined experience for developers and users interacting with smart contract accounts.

### The Anatomy of a Transaction in ZK Sync: The Transaction Struct
At the heart of ZK Sync's transaction processing is a comprehensive `Transaction` struct. This struct is designed to represent all types of transactions within the system. Refering to a definition of this struct found in `lib/foundry-era-contracts/src/system-contracts/contracts/libraries/MemoryTransactionHelper.sol`. This is a helper file based on ZK Sync's actual transaction structure, created to simplify working with transactions in memory during development and tutorials.

Let's break down the key fields within the ZK Sync `Transaction` struct:

* `uint256 txType;`: Defines the type of the transaction. Examples include legacy Ethereum transactions, EIP-2930, EIP-1559, and ZK Sync's specific EIP-712 signed transaction (type `0x71` or `113`), which is particularly relevant for account abstraction.

* `uint256 from;`: The address initiating the transaction.

* `uint256 to;`: The destination address (callee) of the transaction.

* `uint256 gasLimit;`: The maximum amount of gas the transaction is allowed to consume.

* `uint256 gasPerPubdataByteLimit;`: A ZK Sync specific field, setting the limit for gas cost per byte of public data.

* `uint256 maxFeePerGas;`: The maximum fee per gas the sender is willing to pay (similar to EIP-1559).

* `uint256 maxPriorityFeePerGas;`: The maximum priority fee per gas (tip) the sender is willing to pay to the validator (similar to EIP-1559).

* `uint256 paymaster;`: The address of the paymaster contract. If this address is 0, no paymaster is used, and the from account pays the fees. Paymasters, which can sponsor transactions by covering fees, are a native feature in ZK Sync.

* `uint256 nonce;`: The transaction nonce, ensuring sequential processing and preventing replay attacks.

* `uint256 value;`: The amount of ETH (or native currency) being sent with the transaction.

* `uint256[4] reserved;`: An array reserved for future protocol extensions, ensuring forward compatibility.

* `bytes data;`: The calldata for the transaction, containing the function signature and arguments for a contract call, or arbitrary data.

* `bytes signature;`: The cryptographic signature authenticating the transaction. For smart contract accounts, this signature's validation logic is defined by the account itself.

* `bytes32[] factoryDeps;`: An array of bytecode hashes for contracts that need to be deployed along with this transaction. This is crucial for deploying smart contract wallets or any other contracts that the current transaction depends on but are not yet on-chain.

* `bytes paymasterInput;`: Data passed to the paymaster contract if one is specified in the `paymaster` field. This allows the paymaster to have custom logic based on the transaction.

* `bytes reservedDynamic;`: Reserved space for dynamic data, offering further flexibility for future protocol upgrades.

Understanding this `Transaction` struct is pivotal, as it's the primary data structure passed to the IAccount functions.

## Understanding the `IAccount` Interface: Your ZK Sync Smart Wallet Blueprint
The `IAccount.sol` interface defines the standard contract that all smart contract accounts on ZK Sync must adhere to. By implementing this interface, a smart contract can act as a fully-fledged account, capable of initiating transactions, validating signatures, and managing its own execution logic. 

A noteworthy practical consideration during development, particularly for exploring(or learning) purposes, is the handling of the `Transaction` struct. The `IAccount` interface often specifies `Transaction calldata _transaction` for its function parameters. However, to simplify coding and avoid potential complexities with `calldata`-to-`memory` conversions in Solidity (which can sometimes lead to unexpected issues), implementations like `ZkMinimalAccount.sol` might change this to `Transaction memory _transaction`. This is a developer convenience for the implementation phase.

You'll also notice parameters like `_txHash`, `_suggestedSignedHash`, and `_possibleSignedHash` in the `IAccount` functions. These are primarily related to the Bootloader, a low-level system component in ZK Sync responsible for transaction processing. For an initial understanding and implementation of `IAccount`, these hash parameters are often ignored, with the focus placed squarely on the `_transaction` struct.