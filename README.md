Everything is in README.md

# Account Abstraction
Account Abstraction (AA) fundamentally redefines user accounts in Web3. Instead of traditional Externally Owned Accounts (EOAs) controlled solely by a private key, AA allows user accounts to be smart contracts. This paradigm shift enables programmable validity conditions – dictating who can send transactions and under what circumstances – and custom execution logic, offering unprecedented flexibility and security. These smart contract-based accounts are often referred to as "smart contract wallets."

## The Bottleneck: Why Traditional Crypto Wallets Hinder Adoption

The traditional approach to managing crypto assets has long been a significant barrier to widespread adoption. Consider the typical user journey:

1. A user receives a 12-word seed phrase.

2. This seed phrase generates a private key.

3. This private key is the sole authenticator for signing all transactions.

This model, while secure in theory, presents several critical pain points for the average user:

* **Complexity**: Managing seed phrases and private keys is a daunting task. Users are expected to become security experts overnight, safeguarding these cryptic strings of characters.

* **High Stakes**: The loss of a seed phrase or private key typically means irreversible loss of access to all associated funds. There are no "forgot password" options.

* **Security Risks**: If a private key or seed phrase is accidentally leaked or compromised, malicious actors can gain unfettered access to and drain the user's wallet.

* **Gas Fee Friction**: Every on-chain action, no matter how small, requires the user to hold and spend the blockchain's native token (e.g., ETH on Ethereum) for gas fees. This "gas problem" is a constant hurdle, especially for new users who might not have any native tokens to begin with.

* **Limited Wallet Privacy**: All transactions originating from a single private key are linked, potentially revealing a user's activity patterns.

* **Batching Inefficiencies**: Performing multiple operations often requires deploying an intermediary smart contract, adding complexity and cost.

These issues collectively create a poor user experience, making it difficult to onboard new users to the world of decentralized finance and Web3.

## What is Account Abstraction? The Core Shift in Transaction Validation

Account Abstraction fundamentally redefines how transactions are authorized and validated on a blockchain. The core idea is to move away from a rigid system where transaction validity is solely tied to an Elliptic Curve Digital Signature Algorithm (ECDSA) signature generated by a private key. Instead, AA allows for **arbitrary validation logic** defined within a smart contract.

To put it simply:

* **Traditional Model**: Private Key = Wallet. The private key is the ultimate authority.

* **Account Abstraction Model**: Programmable Logic = Wallet. The authority and validation rules are defined by the code within a smart contract account.

This shift means that instead of the blockchain protocol itself dictating that only a private key signature can authorize a transaction from an Externally Owned Account (EOA), the account itself (now a smart contract) dictates the conditions under which a transaction is considered valid.

This programmable validity opens up a wealth of possibilities:

* **Social Login/Recovery**: Users could authorize transactions using familiar credentials like a Google account, GitHub, or even biometrics, abstracting away the need to directly manage private keys.

* **Multi-signature (Multi-sig) Wallets**: Require approvals from multiple parties (e.g., three out of five authorized signers) before a transaction is executed.

* **Spending Limits**: Enforce daily, weekly, or per-transaction spending caps directly at the account level.

* **Time Locks**: Permit transactions only during specific windows (e.g., business hours) or after a certain delay.

* **Parental Controls**: A wallet for a minor could be configured such that transactions initiated by the child require approval from a parent's account before execution.

## Gas Abstraction: Solving the "Need Gas" Problem with Paymasters
A significant corollary of programmable validation is **gas abstraction**. Because the account's validation logic is flexible, AA enables mechanisms where someone other than the user can pay for their transaction gas fees.

This directly addresses the friction point where users need native tokens for every interaction. With AA, a dApp developer, a project, or a dedicated third-party service (known as a "Paymaster") can sponsor transactions. The user can interact with a dApp without needing to first acquire and hold ETH (or the L2's native token) specifically for gas.

## How Account Abstraction Works: EIP-4337 vs. Native Implementations
The implementation of Account Abstraction varies, leading to different levels of complexity. There are two primary approaches:

1. **Ethereum (EIP-4337)**: This standard implements Account Abstraction on top of the existing Ethereum protocol without requiring core consensus changes. It relies on a higher-level infrastructure, including a special smart contract (`EntryPoint.sol`) and an alternative mempool for user operations. EIP-4337 went live on Ethereum mainnet on March 1st, 2023.

2. **Native Account Abstraction (e.g., zkSync)**: Some Layer 2 solutions and newer blockchains build Account Abstraction directly into their core protocol. This often leads to a more streamlined and integrated experience.

### Traditional Ethereum Transaction Flow (Recap)
Before diving into EIP-4337, let's quickly recap the traditional Ethereum transaction flow:

1. **Off-Chain**: A user, using a wallet like MetaMask, signs transaction data with their private key. This signature, along with the transaction details and gas payment, is prepared.

2. **On-Chain**: The signed transaction is broadcast to an Ethereum node.

3. The node validates the transaction (including the signature and sufficient gas) and, if valid, adds it to its local mempool.

4. Miners/validators pick transactions from the mempool to include in a new block, which is then added to the blockchain.

## Account Abstraction on Ethereum via EIP-4337: A Detailed Look
EIP-4337 introduces a new, parallel system for transaction processing that leverages smart contracts to achieve account abstraction. The flow involves several key components:

1. **Deploy a Smart Contract Wallet (SCW)**:
Instead of relying solely on an EOA, the user interacts through a **Smart Contract Wallet (SCW)**. This SCW is a smart contract deployed on the blockchain (e.g., `MyNewAccount.sol`) that contains the custom validation logic. This logic dictates what constitutes a valid authorization for that specific account – it could be a signature from a specific key (mimicking an EOA), a multi-sig condition, or a check against an off-chain authentication service.

2. **Construct and Send a "UserOperation" (UserOp) to the Alt Mempool**:
When a user wants to perform an action (e.g., send tokens, interact with a DeFi protocol), their wallet interface (now AA-aware) constructs a **UserOperation** (`UserOp`) object. This is not a standard Ethereum transaction. The `UserOp` struct, defined in the EIP-4337 specification, includes fields such as:

* `sender`: The address of the user's SCW.

* `nonce`: A sequence number to prevent replay attacks.

* `callData`: The actual operation to be executed by the SCW (e.g., the function call and parameters for an ERC20 transfer).

* Gas-related fields (`callGasLimit`, `verificationGasLimit`, `preVerificationGas`, `maxFeePerGas`, `maxPriorityFeePerGas`).

* `paymasterAndData`: Optional data for specifying a Paymaster to sponsor gas fees.

* `signature`: The signature that satisfies the SCW's custom validation logic.

This `UserOp`, signed according to the SCW's rules, is then sent to a separate, off-chain peer-to-peer network known as the **Alternative Mempool (Alt Mempool)**. This mempool is specifically for `UserOps` and operates independently of Ethereum's main transaction mempool.

3. **Bundlers Process UserOps**:
Specialized nodes participating in the Alt Mempool network are called **Bundlers**. Their role is to:

* Listen for `UserOps` in the Alt Mempool.

* Validate each `UserOp` by simulating its validation logic against the target SCW.

* Bundle multiple valid `UserOps` together into a single, standard Ethereum transaction.

* Crucially, the **Bundler pays the gas fee** for this bundled Ethereum transaction sent to the main Ethereum network. They are later compensated either by the SCWs themselves or by Paymasters.

4. **Bundler Calls the `EntryPoint.sol` Contract**:
The Bundler submits this bundled transaction by calling a specific function (typically `handleOps`) on a single, globally deployed smart contract called `EntryPoint.sol`. This contract (developed and maintained by the `eth-infinitism` group, with support from the Ethereum Foundation) acts as the central orchestrator for EIP-4337. Its canonical address (e.g., `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789` for v0.6/v0.7) is known and trusted.

The `EntryPoint.sol` contract then performs its own set of critical operations:

* It iterates through each `UserOp` in the bundle.

* For each `UserOp`, it first verifies the `UserOp`'s signature and other parameters by calling a validation function on the user's SCW (e.g., `validateUserOp`).

* It checks if the SCW has enough funds to pay the Bundler for gas, or if a specified Paymaster has agreed to cover the costs.

5. **Smart Contract Wallet Executes the Transaction**:
If the validation step in `EntryPoint.sol` (which involves calling the SCW's validation logic) is successful, `EntryPoint.sol` then calls another function on the user's SCW to execute the actual intended operation. This is where the `callData` from the `UserOp` is executed (e.g., making a swap on Uniswap, or lending assets on Aave).

* Importantly, during this execution phase, the `msg.sender` for the target dApp interaction will be the address of the user's SCW, not the Bundler or the `EntryPoint` contract. This ensures that from the perspective of other smart contracts, the SCW is the true originator of the action.
The results of these operations are then recorded on the Ethereum blockchain.

6. **Optional EIP-4337 Add-ons**:

* **Signature Aggregators**: EIP-4337 supports the use of Signature Aggregator contracts. These contracts can be used by `EntryPoint.sol` to validate aggregated signatures (e.g., BLS signatures). This is particularly useful for multi-sig SCWs or for batching operations, as it can significantly reduce gas costs by verifying multiple signatures in a single operation.

* **Paymasters**: As mentioned, a Paymaster is a smart contract that can agree to pay the gas fees for a `UserOp`. The `UserOp` can specify a Paymaster contract and include data that the Paymaster requires for its validation (e.g., a signature from the dApp sponsoring the transaction). If a Paymaster is used and successfully validates, it reimburses the Bundler via the `EntryPoint.sol` contract. If no Paymaster is used, the user's SCW must have sufficient native token balance, which `EntryPoint.sol` will transfer to the Bundler as compensation.

The EIP-4337 flow, while powerful, involves several interconnected components: the user's SCW, the UserOp object, the Alt Mempool, Bundlers, and the central `EntryPoint.sol` contract.

## Native Account Abstraction: The zkSync Example
Blockchains with native Account Abstraction, such as zkSync Era, integrate AA principles directly into their core protocol, often resulting in a simpler architecture for developers and users.

In zkSync Era:

* The roles of the Alt Mempool and Bundlers are effectively handled by the regular chain nodes/sequencers.

* **Every account is fundamentally a smart contract**. Even when a user creates an account using a familiar tool like MetaMask (which traditionally generates an EOA), zkSync automatically deploys a default smart contract account implementation for that address.

* This default account contract (e.g., `DefaultAccount.sol` in the `matter-labs/era-contracts` repository) implements standard interfaces like `IAccount` and includes functions such as `validateTransaction`, `executeTransaction`, and `isValidSignature`. By default, this contract mimics traditional EOA behavior, validating transactions based on an ECDSA signature from the associated private key.

* However, users or developers can **override** this default implementation by deploying custom smart contract code to their account address. This custom code can then define any arbitrary validation logic, effectively turning any account into a fully programmable smart contract wallet.

The simplified flow on a native AA chain like zkSync might look like this:

1. **Off-Chain**: A signer (which could be a traditional private key, a social login mechanism, or a multi-sig scheme) signs the transaction data according to the account's logic.

2. **On-Chain**: The signed transaction is sent to zkSync nodes. These nodes natively understand AA and can directly call the validation logic within the user's account contract.

3. If valid, the transaction is executed by the user's account contract, and the results are included in a block on the zkSync blockchain.

This native approach bypasses the need for a separate Alt Mempool and the `EntryPoint.sol` contract, as the core protocol itself is designed to handle programmable account validity.

## The Future is Abstracted: Enhanced Usability for Web3
Account Abstraction, whether through EIP-4337 on Ethereum or via native implementations on Layer 2s and other blockchains, represents a monumental step towards improving blockchain usability. While the EIP-4337 mechanism on Ethereum involves a complex interplay of off-chain and on-chain components, its goal is to make interacting with Web3 applications as seamless and intuitive as using Web2 applications.

By abstracting away the complexities of private key management and gas payments, AA paves the way for features like social recovery, sponsored transactions, spending limits, and much more. Ultimately, this will lower the barrier to entry, making decentralized technologies more accessible to a broader audience and helping to onboard the next wave of users into the crypto ecosystem.

---

## Ethereum's Approach to Account Abstraction: ERC-4337
The Ethereum ecosystem primarily tackles Account Abstraction through the ERC-4337 standard. This standard introduces a decentralized infrastructure layer without requiring consensus-level protocol changes.

**Key Components of ERC-4337**:

* `EntryPoint.sol`: This is a globally recognized, trusted smart contract. It acts as the central coordinator for AA transactions. Bundlers submit `UserOperations` to this contract, which then orchestrates their validation and execution against the target smart contract wallet.

* `UserOperation`: Instead of standard Ethereum transactions, users (or dApps on their behalf) create `UserOperation` objects. These objects detail the intended action, signature, gas parameters, and other necessary data for the smart contract wallet.

* `Alt-Mempool`: `UserOperations` are not broadcast to the standard Ethereum transaction mempool. Instead, they are sent to a separate, alternative mempool (often called an "alt-mempool").

* **Bundlers**: These are specialized actors who monitor the alt-mempool. They select `UserOperations`, bundle them into a single standard Ethereum transaction, and submit this bundle to the `EntryPoint.sol` contract. Bundlers pay the gas for this Layer 1 transaction and are subsequently reimbursed, typically from the smart contract wallet or a Paymaster.

**Minimal Ethereum AA Implementation: `MinimalAccount.sol`**

The `MinimalAccount.sol` contract, found within the `src/ethereum/` directory, serves as a foundational example of an ERC-4337 compatible smart contract wallet. Its primary design goal is simplicity, offering a clear starting point for developers.

   * **Core Functionality**:

       * It permits transaction initiation by either its "owner" (the EOA that deployed it) or the `EntryPoint.sol` contract.

       * The `validateUserOp` function is crucial for verifying an incoming `UserOperation` from the `EntryPoint`. It typically checks signatures and other conditions.

       * The `execute` function is called by the `EntryPoint` after successful validation to perform the actual transaction logic (e.g., calling another contract).

   * **Extensibility**: While minimal, `MinimalAccount.sol` is designed for extension. Developers can incorporate:

       * **Paymaster Logic**: To allow third parties (Paymasters) to sponsor transaction fees.

       * **Custom Signature Schemes**: Integrating alternative signature validation, potentially via a Signature Aggregator.

       * **Spending Allowances/Limits**: Enforcing rules on transaction values or frequencies.

       * **Session Keys**: Implementing temporary, permission-restricted keys (e.g., using Google session keys) for specific interactions.

**Ethereum AA Transaction Flow (ERC-4337)**:

1. **UserOperation Creation**: A user, often interacting through a dApp, signs data that forms a `UserOperation`.

2. **Submission to Alt-Mempool**: The `UserOperation` is sent to an alt-mempool.

3. **Bundler Action**: Bundlers retrieve `UserOperations` from the alt-mempool, package them into a standard Ethereum transaction, and submit this bundle to the `EntryPoint.sol` contract on-chain.

4. **Validation**: The `EntryPoint.sol` contract calls the `validateUserOp` function on the target smart contract wallet (e.g., an instance of `MinimalAccount.sol`). This function verifies the operation's legitimacy (e.g., signature, nonce).

5. **Execution**: If `validateUserOp` succeeds, the `EntryPoint.sol` contract then calls the `execute` function on the smart contract wallet, which carries out the intended action (e.g., an ERC20 token transfer or a smart contract interaction).

6. **Optional Paymaster Involvement**: A Paymaster contract can be specified in the `UserOperation` to cover the gas fees, enabling gasless experiences for the end-user.

## zkSync's Native Account Abstraction: A Built-in Solution
zkSync approaches Account Abstraction differently by integrating it directly into its Layer 2 protocol. This native implementation offers a more streamlined experience and distinct characteristics compared to Ethereum's ERC-4337.

**Key Differences and Features in zkSync Native AA**:

* **No Alt-Mempool**: AA transactions on zkSync are submitted to the regular zkSync mempool, just like EOA transactions. There's no need for a separate mempool infrastructure.

* **Type 113 Transactions**: AA transactions are designated as `Type 113` (hexadecimal `0x71`). This specific type signals to the zkSync protocol that the transaction originates from a smart contract account and requires special handling.

* **Bootloader**: A critical system-level component in zkSync, the Bootloader plays a central role in processing AA transactions. During both the validation and execution phases of an AA transaction, the `msg.sender` to the smart contract wallet will be the Bootloader's address.

* **Smart Contract as `from` Address**: A significant distinction is that in zkSync, the `from` field of a `Type 113` transaction can be the address of the smart contract wallet itself. This contrasts with Ethereum, where the `from` field is always an EOA.

**Minimal zkSync AA Implementation: `ZkMinimalAccount.sol`**

The `ZkMinimalAccount.sol` contract, located in `src/zksync/` of the repository, demonstrates a basic smart contract wallet utilizing zkSync's native AA.

* **Important Contract Functions**:

   * `validateTransaction(bytes32 _txHash, bytes32 _suggestedSignedHash, Transaction _transaction)`: This function is paramount. It's called by the Bootloader to validate the incoming transaction. Responsibilities include verifying signatures against `_suggestedSignedHash` (which is `keccak256(abi.encodePacked(txHash, EIP1271_SUCCESS_RETURN_VALUE))`) and, crucially, incrementing the account's nonce to prevent replay attacks.

   * `executeTransaction(bytes32 _txHash, bytes32 _suggestedSignedHash, Transaction _transaction)`: After successful validation, the Bootloader calls this function to execute the actual logic defined in the `_transaction` payload.

   * `payForTransaction(...)`: This function (or logic within `validateTransaction`) handles the payment of transaction fees, ensuring the account can cover the costs or that a Paymaster will.

**zkSync Native AA Transaction Flow**:

The lifecycle of a `Type 113` transaction on zkSync involves two main phases, orchestrated by the zkSync system and the Bootloader:

* **Phase 1: Validation**

   1. **Submission**: The user (or dApp) sends the `Type 113` transaction to a zkSync API client. The `from` field of this transaction is the address of the `ZkMinimalAccount.sol` instance.

   2. `msg.sender` **is Bootloader**: For both validation and execution phases, the `msg.sender` to the `ZkMinimalAccount.sol` will be the Bootloader.

   3. **Nonce Check (System)**: The API client, interacting with the NonceHolder system contract, verifies the uniqueness of the transaction's nonce for the account.

   4. **Account Validation Call**: The API client (via the Bootloader) calls `validateTransaction` on the `ZkMinimalAccount.sol`. This function must perform signature checks and update the account's nonce.

   5. **Nonce Update Verification (System)**: The API client checks if the `ZkMinimalAccount.sol` correctly updated its nonce.

   6. **Fee Payment Check (System)**: The API client calls `payForTransaction` on the account (or invokes Paymaster logic if specified) to ensure the transaction fees can be covered.

   7. **Bootloader Payment Verification (System)**: The API client confirms that the Bootloader will be compensated for processing the transaction.

* **Phase 2: Execution**

   1. **To Sequencer**: The validated transaction is passed from the API client to the main zkSync node/sequencer.

   2. **Account Execution Call**: The main node (via the Bootloader) calls `executeTransaction` on the `ZkMinimalAccount.sol`, which then performs the intended operations.

   3. **Post-Transaction (Optional)**: If a Paymaster was involved, its `postTransaction` method might be called.

## Comparing Implementations: Ethereum (ERC-4337) vs. zkSync Native AA
Understanding the practical differences is key when observing on-chain activity.

* **zkSync Sepolia Example (Native AA)**:

   * Consider a transaction approving USDC spending from a deployed `ZkMinimalAccount` (e.g., `0xCB38...5691`).

   * On the zkSync Sepolia explorer, the `from` address of this transaction (hash `0x4322...d0fd`) will be the `ZkMinimalAccount` smart contract address itself. This directly demonstrates the smart contract initiating the call.

* **Ethereum (Arbitrum Example with ERC-4337)**:

   * Consider a similar USDC approval from a `MinimalAccount` deployed on Arbitrum (an Ethereum L2 that can support ERC-4337).

   * On Arbiscan, the transaction (hash `0x03f9...154b`) will show its `from` **address** as a **Bundler** (e.g., `0x9EA9...F6fC`).

   * The transaction's `to` **address** will be the `EntryPoint.sol` contract (e.g., version 0.7.0 at `0x000...032`).

   * However, by inspecting the transaction logs, one would find an `Approval` event emitted by the USDC contract where the `owner` (the account granting approval) is the MinimalAccount smart contract wallet address (e.g., `0x83Ad...AAf`). This confirms that, despite the Bundler being the transaction submitter, the smart contract wallet was the effective initiator of the state change via the EntryPoint.


## Core Components: Paymasters and Signature Aggregators
Both ERC-4337 and zkSync's native AA can be enhanced with optional components:

  * **Paymasters**: These are smart contracts that can sponsor transaction fees on behalf of users. This enables "gasless" transactions for the end-user, where the dApp, a protocol, or another entity covers the costs. Paymasters are integrated into the validation flow, agreeing to pay if certain conditions are met.

  * **Signature Aggregators**: In scenarios involving multiple `UserOperations` (especially in ERC-4337) or complex multi-signature schemes within a single account, Signature Aggregators can validate multiple signatures in a batch. This can lead to significant gas savings by reducing the on-chain verification overhead.

## Code Overview and Extensibility

* `src/ethereum/MinimalAccount.sol`: For ERC-4337 compatible chains.

* `src/zksync/ZkMinimalAccount.sol`: For zkSync and its native AA.

These minimal contracts are designed as starting points. The true power of Account Abstraction is unlocked by extending their validation logic (`validateUserOp` on Ethereum, `validateTransaction` on zkSync). Developers can build upon these bases to incorporate:

* **Advanced Paymaster integrations**.

* **Novel signature schemes** (e.g., BLS signatures, quantum-resistant signatures).

* **Granular spending allowances** or time-based spending limits.

* **Session keys** for enhanced dApp interactions, allowing temporary, restricted access without exposing primary owner keys. For example, a game might be granted a session key that can only sign transactions related to in-game actions for a limited duration.

## Unlocking Advanced Use Cases with Account Abstraction
The customizability offered by these minimal AA frameworks paves the way for sophisticated wallet features:

* **Session Keys**: Granting temporary, limited permissions to dApps or other services for specific actions (e.g., a gaming session key that can only sign game-related transactions for a set period).

* **Custom Multisig**: Implementing complex N-of-M signature schemes beyond standard multisigs, potentially involving role-based access or conditional approvals (e.g., requiring 2 out of 3 specific signers plus a time-locked passcode).

* **Social Recovery**: Enabling users to regain access to their accounts through a set of trusted guardians or social connections, rather than relying solely on a seed phrase.

* **Gas Sponsorship**: Facilitating frictionless onboarding and interaction by allowing dApps or protocols to cover transaction fees for their users via Paymasters.

### Key Takeaways for Developers
Building and experimenting with both the Ethereum ERC-4337 style and zkSync's native Account Abstraction implementations provides invaluable insight into their respective nuances, strengths, and trade-offs. The core innovation lies in the programmable validation logic within the smart contract wallet itself (`validateUserOp` or `validateTransaction`). This programmability is what empowers developers to create highly secure, user-friendly, and feature-rich Web3 experiences, moving beyond the limitations of traditional EOA wallets. By understanding these foundational patterns, developers can choose the most suitable AA approach for their target blockchain and application needs.

## Understanding the ERC-4337 Interaction Flow
To correctly implement `MinimalAccount.sol`, we must understand the ERC-4337 standard. This Ethereum Improvement Proposal (EIP) outlines the architecture for account abstraction without requiring consensus-layer changes. You can find the full specification at eips.ethereum.org/EIPS/eip-4337.

The ERC-4337 flow can be visualized as follows:

1. **Off-Chain User Action**: A user signs data, which forms a `UserOperation`. This `UserOperation` is essentially a pseudo-transaction that describes the action the user wants their smart contract wallet to perform.

2. **Alternative Mempool (Bundlers)**: The signed `UserOperation` is sent to specialized nodes called Bundlers. Bundlers are actors in the ERC-4337 ecosystem that listen for `UserOperations` on an alternative, off-chain mempool. They validate these operations (checking for correctness, potential profitability, etc.).

3. **On-Chain Execution via EntryPoint**: Bundlers package valid `UserOperations` into a standard Ethereum transaction and send it to a globally deployed singleton contract called the `EntryPoint.sol`.

4. **EntryPoint Contract Logic**: The `EntryPoint` contract is the central orchestrator. It first verifies the `UserOperation`. This verification step involves calling a specific function on the user's smart contract wallet (`MinimalAccount.sol`). If verification succeeds, the `EntryPoint` then executes the UserOperation, again by calling a function on the user's smart contract wallet. The `EntryPoint` also handles interactions with Paymasters (contracts that can sponsor gas fees) and Signature Aggregators (for more efficient signature schemes).

5. **Smart Contract Wallet (Account)**: `MinimalAccount.sol` is the user's smart contract wallet. The `EntryPoint` interacts directly with this contract for both validating the `UserOperation` (e.g., checking the signature) and executing the intended action (e.g., calling another contract).

6. **Blockchain Inclusion**: The entire interaction, initiated by the Bundler's transaction to the `EntryPoint`, is ultimately included in a block on the Ethereum blockchain.

The `UserOperation` struct, defined by ERC-4337, is crucial. It bundles all necessary data for an off-chain pseudo-transaction, including fields like `sender` (the smart contract wallet's address), `nonce`, `callData` (the action to execute), various gas limits, `paymasterAndData`, and the `signature`. This is the data structure passed around in the alt-mempool.

When the `EntryPoint` contract interacts with an account contract on-chain, it uses a packed version of this `UserOperation`.

