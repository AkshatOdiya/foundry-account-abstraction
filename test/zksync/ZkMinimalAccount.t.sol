/**
 * @notice run your test using '--system-mode=true'
 * for example: `forge test --mt testZkValidateTransaction --zksync --system-mode=true`
 */

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {ZkMinimalAccount} from "src/zksync/ZkMinimalAccount.sol";
import {ERC20Mock} from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
import {ACCOUNT_VALIDATION_SUCCESS_MAGIC} from
    "lib/foundry-era-contracts/src/system-contracts/contracts/interfaces/IAccount.sol";
import {
    Transaction,
    MemoryTransactionHelper
} from "lib/foundry-era-contracts/src/system-contracts/contracts/libraries/MemoryTransactionHelper.sol";
import {BOOTLOADER_FORMAL_ADDRESS} from "lib/foundry-era-contracts/src/system-contracts/contracts/Constants.sol";

contract ZkMinimalAccountTest is Test {
    ZkMinimalAccount minimalAccount;
    ERC20Mock usdc;
    uint256 constant AMOUNT = 1e18;
    bytes32 constant EMPTY_BYTES32 = bytes32(0);
    address constant ANVIL_DEFAULT_ACCOUNT = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266; // public key

    /**
     * @notice setup
     *
     * The signature generated by _signTransaction (using ANVIL_DEFAULT_KEY) will be valid because the minimalAccount's owner is ANVIL_DEFAULT_ACCOUNT.
     *
     * The balance check within validateTransaction will pass because the account has been funded with ETH using vm.deal
     */
    function setUp() public {
        minimalAccount = new ZkMinimalAccount();
        minimalAccount.transferOwnership(ANVIL_DEFAULT_ACCOUNT);
        usdc = new ERC20Mock();
        vm.deal(address(minimalAccount), AMOUNT);
    }

    function testZkOwnerCanExecuteCommands() public {
        // Arrange
        address dest = address(usdc);
        uint256 value = 0;
        bytes memory functionData = abi.encodeWithSelector(ERC20Mock.mint.selector, address(minimalAccount), AMOUNT);
        Transaction memory transaction =
            _createUnsignedTransaction(minimalAccount.owner(), 113, dest, value, functionData);
        // Act
        vm.prank(minimalAccount.owner());
        minimalAccount.executeTransaction(EMPTY_BYTES32, EMPTY_BYTES32, transaction);

        // Assert
        assertEq(usdc.balanceOf(address(minimalAccount)), AMOUNT);
    }

    function testZkValidateTransaction() public {
        // Arrange
        address dest = address(usdc);
        uint256 value = 0;
        bytes memory functionData = abi.encodeWithSelector(ERC20Mock.mint.selector, address(minimalAccount), AMOUNT);
        Transaction memory transaction =
            _createUnsignedTransaction(minimalAccount.owner(), 113, dest, value, functionData);
        transaction = _signTransaction(transaction);

        // Act
        vm.prank(BOOTLOADER_FORMAL_ADDRESS);
        bytes4 magic = minimalAccount.validateTransaction(EMPTY_BYTES32, EMPTY_BYTES32, transaction);

        // Assert
        assertEq(magic, ACCOUNT_VALIDATION_SUCCESS_MAGIC);
    }

    function _createUnsignedTransaction(
        address from,
        uint8 transactionType,
        address to,
        uint256 value,
        bytes memory data
    ) internal view returns (Transaction memory) {
        uint256 nonce = vm.getNonce(address(minimalAccount));
        bytes32[] memory factoryDeps = new bytes32[](0);
        return Transaction({
            txType: transactionType,
            from: uint256(uint160(from)),
            to: uint256(uint160(to)),
            gasLimit: 16777216,
            gasPerPubdataByteLimit: 16777216,
            maxFeePerGas: 16777216,
            maxPriorityFeePerGas: 16777216,
            paymaster: 0,
            nonce: nonce,
            value: value,
            reserved: [uint256(0), uint256(0), uint256(0), uint256(0)],
            data: data,
            signature: hex"",
            factoryDeps: factoryDeps,
            paymasterInput: hex"",
            reservedDynamic: hex""
        });
    }

    function _signTransaction(Transaction memory transaction) internal view returns (Transaction memory) {
        bytes32 digest = MemoryTransactionHelper.encodeHash(transaction);
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint256 ANVIL_DEFAULT_PRIVATE_KEY = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;
        if (block.chainid == 31337) {
            (v, r, s) = vm.sign(ANVIL_DEFAULT_PRIVATE_KEY, digest);
        } else {
            (v, r, s) = vm.sign(vm.envUint("SEPOLIA_PRIVATE_KEY"), digest);
        }
        Transaction memory signedTransaction = transaction;
        signedTransaction.signature = abi.encodePacked(r, s, v); // r,s,v see the order
        return signedTransaction;
    }
}

/**
 * @notice Core Concepts in zkSync AA Testing
 *
 * Native Account Abstraction (zkSync): Unlike Ethereum L1 where ERC-4337 is an application-level standard built on top of existing EOA infrastructure, zkSync has AA capabilities built directly into its protocol.
 * This fundamental difference means transaction validation, execution, and fee payment mechanisms are handled differently and are more deeply integrated into the L2's architecture.
 *
 * The Transaction Struct (zkSync): As highlighted earlier, this struct is a cornerstone of zkSync's AA. It bundles all necessary information for an operation (target, value, data,
 * nonce, gas parameters, factory dependencies, paymaster details, and signatures) into a single, comprehensive object. Your tests will frequently involve constructing and manipulating these Transaction structs.
 *
 * The Bootloader (zkSync): This is a special system contract on zkSync that plays a critical role in the transaction lifecycle. For AA accounts, the bootloader is often responsible for initiating the validation
 * and execution phases, including potentially calling the executeTransaction (or similar) function on your smart account.
 *
 * Foundry Testing Specifics for zkSync: While many standard Foundry testing primitives like vm.prank, assertions, and direct contract deployment (new ContractName()) work seamlessly, interacting with zkSync's
 * unique AA features requires a deeper understanding of the zkSync protocol. This includes correctly formatting the Transaction struct and understanding how system contracts like the bootloader might influence transaction flow.
 *
 * Deployment Scripts (Bash): For more complex deployment scenarios, especially those mimicking production environments or involving intricate factory dependencies on zkSync, using bash scripts that leverage forge script or
 * forge create with zkSync-specific flags and RPC endpoints becomes necessary. AI tools like GitHub Copilot or ChatGPT can be helpful in scaffolding these scripts.
 *
 * Naming Consistency: A minor but practical point is maintaining consistent naming conventions for directories (e.g., zksync vs. zkSync) between your source code (src) and test (test) folders to avoid potential import issues and maintain project clarity.
 */

/**
 * @notice Key Considerations for zkSync Transactions
 *
 * When constructing zkSync Transaction structs, keep the following points in mind:
 *
 * Transaction Types (txType): For zkSync native Account Abstraction, the txType is 113 (hex 0x71).
 * zkSync supports other transaction types (e.g., Legacy, EIP-2930, EIP-1559), but 113 is specific to AA.
 *
 * Address Casting (uint256(uint160(address))): A critical detail is that the from and to fields in the zkSync
 * Transaction struct are uint256, not the standard address type. The conversion uint256(uint160(someAddress)) is the standard way
 * to cast an address (which is 160 bits) to a uint256. This distinction arises from lower-level data representation, a topic often
 * explored in depth in areas like EVM assembly or formal verification.
 *
 * Nonce Handling (vm.getNonce): In our Foundry test, we use the vm.getNonce(address) cheatcode to retrieve the nonce for the minimalAccount.
 * It's important to recognize that this is a simplification provided by Foundry. In a live zkSync Era environment, nonces are managed by a dedicated NonceHolder system contract.
 * For robust, off-Foundry applications, you would interact with this NonceHolder contract to get the correct nonce.
 *
 * Pubdata (gasPerPubdataByteLimit): This field accounts for the cost associated with publishing data from zkSync (L2) back to Ethereum (L1).
 * This is a distinct cost factor in zkEVM rollups, reflecting the L1 data availability requirements.
 *
 * Unsigned Transaction: Our helper function is named _createUnsignedTransaction (in test file) because we explicitly set the signature field to an empty byte string (hex"").
 * This is suitable for owner-initiated actions within tests where the signature verification path might be bypassed or handled differently.
 *
 * Factory Dependencies (factoryDeps): This field is crucial if your transaction intends to deploy new contracts through the smart contract account.
 * It holds the bytecode hashes of these new contracts. If your transaction only calls existing contracts, this array can be empty.
 *
 * Paymaster Fields (paymaster, paymasterInput): These fields are used when implementing sponsored transactions via a paymaster.
 * If you're not using a paymaster, paymaster should be the zero address, and paymasterInput can be empty.
 *
 * Reserved Fields: These are populated with default empty/zero values as they are designated for future protocol enhancements or features.
 */
